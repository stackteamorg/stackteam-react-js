{"ast":null,"code":"import _slicedToArray from \"/home/mahdi/Workspace/stack-eco-system/eco-system/stackteam/stackteam-react-js/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport React, { useMemo, useCallback, useState, useEffect, useRef } from 'react';\nimport throttle from 'lodash.throttle';\nvar animatedClass = 'animate__animated';\nvar serverSide = typeof window === 'undefined';\nvar scrollableParentRefInitialValue = undefined;\n\nif (!serverSide) {\n  scrollableParentRefInitialValue = window;\n}\n\nexport var AnimationOnScroll = function AnimationOnScroll(_ref) {\n  var _ref$offset = _ref.offset,\n      offset = _ref$offset === void 0 ? 150 : _ref$offset,\n      _ref$duration = _ref.duration,\n      duration = _ref$duration === void 0 ? 1 : _ref$duration,\n      styleProps = _ref.style,\n      classNameProps = _ref.className,\n      _ref$initiallyVisible = _ref.initiallyVisible,\n      initiallyVisible = _ref$initiallyVisible === void 0 ? false : _ref$initiallyVisible,\n      animateIn = _ref.animateIn,\n      afterAnimatedIn = _ref.afterAnimatedIn,\n      animateOut = _ref.animateOut,\n      _ref$delay = _ref.delay,\n      delay = _ref$delay === void 0 ? 0 : _ref$delay,\n      _ref$animatePreScroll = _ref.animatePreScroll,\n      animatePreScroll = _ref$animatePreScroll === void 0 ? true : _ref$animatePreScroll,\n      afterAnimatedOut = _ref.afterAnimatedOut,\n      scrollableParentSelector = _ref.scrollableParentSelector,\n      _ref$animateOnce = _ref.animateOnce,\n      animateOnce = _ref$animateOnce === void 0 ? false : _ref$animateOnce,\n      children = _ref.children;\n\n  var _useState = useState(animatedClass),\n      _useState2 = _slicedToArray(_useState, 2),\n      classes = _useState2[0],\n      setClasses = _useState2[1];\n\n  var _useState3 = useState({\n    animationDuration: \"\".concat(duration, \"s\"),\n    opacity: initiallyVisible ? 1 : 0\n  }),\n      _useState4 = _slicedToArray(_useState3, 2),\n      style = _useState4[0],\n      setStyle = _useState4[1];\n\n  var node = useRef(null);\n  var animating = useRef(false);\n  var visibilityRef = useRef({\n    onScreen: false,\n    inViewport: false\n  });\n  var delayedAnimationTORef = useRef(undefined);\n  var callbackTORef = useRef(undefined);\n  var scrollableParentRef = useRef(scrollableParentRefInitialValue);\n  var getElementTop = useCallback(function (elm) {\n    var yPos = 0;\n\n    while (elm && elm.offsetTop !== undefined && elm.clientTop !== undefined) {\n      yPos += elm.offsetTop + elm.clientTop;\n      elm = elm.offsetParent;\n    }\n\n    return yPos;\n  }, []);\n  var getScrollPos = useCallback(function () {\n    if (scrollableParentRef.current.pageYOffset !== undefined) {\n      return scrollableParentRef.current.pageYOffset;\n    }\n\n    return scrollableParentRef.current.scrollTop;\n  }, [scrollableParentRef]);\n  var getScrollableParentHeight = useCallback(function () {\n    if (scrollableParentRef.current.innerHeight !== undefined) {\n      return scrollableParentRef.current.innerHeight;\n    }\n\n    return scrollableParentRef.current.clientHeight;\n  }, [scrollableParentRef]);\n  var getViewportTop = useCallback(function () {\n    return getScrollPos() + offset;\n  }, [offset, getScrollPos]);\n  var getViewportBottom = useCallback(function () {\n    return getScrollPos() + getScrollableParentHeight() - offset;\n  }, [offset, getScrollPos, getScrollableParentHeight]);\n  var isInViewport = useCallback(function (y) {\n    return y >= getViewportTop() && y <= getViewportBottom();\n  }, [getViewportTop, getViewportBottom]);\n  var isAboveViewport = useCallback(function (y) {\n    return y < getViewportTop();\n  }, [getViewportTop]);\n  var isBelowViewport = useCallback(function (y) {\n    return y > getViewportBottom();\n  }, [getViewportBottom]);\n  var inViewport = useCallback(function (elementTop, elementBottom) {\n    return isInViewport(elementTop) || isInViewport(elementBottom) || isAboveViewport(elementTop) && isBelowViewport(elementBottom);\n  }, [isInViewport, isAboveViewport, isBelowViewport]);\n  var isAboveScreen = useCallback(function (y) {\n    return y < getScrollPos();\n  }, [getScrollPos]);\n  var isBelowScreen = useCallback(function (y) {\n    return y > getScrollPos() + getScrollableParentHeight();\n  }, [getScrollPos, getScrollableParentHeight]);\n  var onScreen = useCallback(function (elementTop, elementBottom) {\n    return !isAboveScreen(elementBottom) && !isBelowScreen(elementTop);\n  }, [isAboveScreen, isBelowScreen]);\n  var getVisibility = useCallback(function () {\n    var elementTop = getElementTop(node.current) - getElementTop(scrollableParentRef.current);\n    var elementBottom = elementTop + node.current.clientHeight;\n    return {\n      inViewport: inViewport(elementTop, elementBottom),\n      onScreen: onScreen(elementTop, elementBottom)\n    };\n  }, [getElementTop, node, inViewport, onScreen, scrollableParentRef]);\n  var visibilityHasChanged = useCallback(function (previousVis, currentVis) {\n    return previousVis.inViewport !== currentVis.inViewport || previousVis.onScreen !== currentVis.onScreen;\n  }, []);\n  var animate = useCallback(function (animation, callback) {\n    delayedAnimationTORef.current = setTimeout(function () {\n      animating.current = true;\n      setClasses(\"\".concat(animatedClass, \" \").concat(animation));\n      setStyle({\n        animationDuration: \"\".concat(duration, \"s\")\n      });\n      callbackTORef.current = setTimeout(callback, duration * 1000);\n    }, delay);\n  }, [animating, delay, duration]);\n  var animateInTrigger = useCallback(function (callback) {\n    animate(animateIn, function () {\n      if (!animateOnce) {\n        setStyle({\n          animationDuration: \"\".concat(duration, \"s\"),\n          opacity: 1\n        });\n        animating.current = false;\n      }\n\n      var vis = getVisibility();\n\n      if (callback) {\n        callback(vis);\n      }\n    });\n  }, [animating, animateIn, animateOnce, duration, animate, getVisibility]);\n  var animateOutTrigger = useCallback(function (callback) {\n    animate(animateOut, function () {\n      setClasses(animatedClass);\n      setStyle({\n        animationDuration: \"\".concat(duration, \"s\"),\n        opacity: 0\n      });\n      var vis = getVisibility();\n\n      if (vis.inViewport && animateIn) {\n        animateInTrigger(afterAnimatedIn);\n      } else {\n        animating.current = false;\n      }\n\n      if (callback) {\n        callback(vis);\n      }\n    });\n  }, [animating, animate, animateIn, duration, afterAnimatedIn, animateInTrigger, animateOut, getVisibility]);\n  var handleScroll = useCallback(function () {\n    if (!animating.current) {\n      var visibility = visibilityRef.current;\n      var currentVis = getVisibility();\n\n      if (visibilityHasChanged(visibility, currentVis)) {\n        clearTimeout(delayedAnimationTORef.current);\n\n        if (!currentVis.onScreen) {\n          setClasses(animatedClass);\n          setStyle({\n            animationDuration: \"\".concat(duration, \"s\"),\n            opacity: initiallyVisible ? 1 : 0\n          });\n        } else if (currentVis.inViewport && animateIn) {\n          animateInTrigger(afterAnimatedIn);\n        } else if (currentVis.onScreen && visibility.inViewport && animateOut && node.current.style.opacity === '1') {\n          animateOutTrigger(afterAnimatedOut);\n        }\n\n        visibilityRef.current = currentVis;\n      }\n    }\n  }, [afterAnimatedIn, afterAnimatedOut, animateIn, animateInTrigger, animateOut, duration, initiallyVisible, visibilityHasChanged, animateOutTrigger, getVisibility]);\n  var listener = useMemo(function () {\n    return throttle(function () {\n      handleScroll();\n    }, 50);\n  }, [handleScroll]);\n  useEffect(function () {\n    if (!serverSide) {\n      var parentSelector = scrollableParentSelector;\n      scrollableParentRef.current = parentSelector ? document.querySelector(parentSelector) : window;\n\n      if (scrollableParentRef.current && scrollableParentRef.current.addEventListener) {\n        scrollableParentRef.current.addEventListener('scroll', listener);\n      } else {\n        console.warn(\"Cannot find element by locator: \".concat(scrollableParentSelector));\n      }\n\n      if (animatePreScroll) {\n        handleScroll();\n      }\n\n      return function () {\n        clearTimeout(delayedAnimationTORef.current);\n        clearTimeout(callbackTORef.current);\n\n        if (window && window.removeEventListener) {\n          window.removeEventListener('scroll', listener);\n        }\n      };\n    }\n  }, [handleScroll, scrollableParentSelector, scrollableParentRef, listener, animatePreScroll]);\n  return /*#__PURE__*/React.createElement(\"div\", {\n    ref: node,\n    className: classNameProps ? \"\".concat(classNameProps, \" \").concat(classes) : classes,\n    style: Object.assign({}, style, styleProps)\n  }, children);\n};","map":null,"metadata":{},"sourceType":"module"}